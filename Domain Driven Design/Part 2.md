
- In an OO program, UI, db and other support code often gets written directly into the business objects. Additionally business logic is embedded in the behaviour of UI widgets and db scripts. This happens because it is the easiest way to make things work, in the short term.
- When the domain related code is diffused through this large amount of other code, it becomes extremely difficult to see and reason about. Superficial changes changes to the UI can actually change business logic. Changing business rules may require meticulous tracing of UI code, db code or other program elements. Implementing coherent model-driven objects becomes impractical. Automated testing is awkward. With all those technologies and logic involved in each activity, a program must be kept very simple or it becomes impossible to understand. - pg 52
Week of 19/08
- We need to be able to pick out elements of our model and see them as a system, not to be distracted by the process of picking them out of a much larger mix of objects, like identifying constellations lost in the sky. This requires decoupling the domain objects from other functions of the system so they are not lost in the mass and so the domain concepts are not blurred and confused with concepts related to software tech.
- The essential principle of layering is that an element of a layer has dependencies only on other elements of the layers "beneath" it. Communication upwards must be through some indirect mechanism - pg 53
	- User Interface / Presentation Layer - Used for showing and interpreting user's commands.
	- App Layer - Defines the jobs software is suppose to do and directs the expressive domain objects to work out problems. The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the app layers of other systems. It does not contain business rules or knowledge but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.
	- Domain Layer - Responsible for representing concepts of the business, information about the business situation and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infra
	- Infra Layer - Provide generic technical capabilities that support the higher layers: message sending for the application, persistence of the domain, drawing widgets for the UI, etc. The infra layer may also support the pattern of interactions between the four layers through an architectural framework.
- Partition a complex program into layers, develop a design within each layer that is cohesive and is dependent only on the layers below. Follow standard architectural patterns to provide loose coupling to the layers above. Concentration the all the code related to the domain model in one layer and isolate it from the user interface, app, and infra code. This allows a model to evolve rich enough and clear enough to effectively capture essential business knowledge and put it to work.

#### Relating Layers
- Layers are meant to be loosely coupled, with design dependencies in only one direction.
- When an object of a lower level needs to communicate upward (beyond answering a direct query) we need another mechanism, drawing on architectural patterns for relating layers such as callbacks or observers. - pg 55

### A model expressed in software
- Aspects of the domain that are more clearly expressed as actions/operations are often best expressed as services. A service is something that will be done for a client on request - pg 60